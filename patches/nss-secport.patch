Index: mozilla/security/nss/lib/util/secport.c
===================================================================
RCS file: /cvsroot/mozilla/security/nss/lib/util/secport.c,v
retrieving revision 1.26
diff -u -p -u -8 -r1.26 secport.c
--- mozilla/security/nss/lib/util/secport.c	24 Dec 2009 03:37:46 -0000	1.26
+++ mozilla/security/nss/lib/util/secport.c	21 Jan 2010 22:47:00 -0000
@@ -47,17 +47,16 @@
 #include "seccomon.h"
 #include "prmem.h"
 #include "prerror.h"
 #include "plarena.h"
 #include "secerr.h"
 #include "prmon.h"
 #include "nssilock.h"
 #include "secport.h"
-#include "prvrsion.h"
 #include "prenv.h"
 
 #ifdef DEBUG
 #define THREADMARK
 #endif /* DEBUG */
 
 #ifdef THREADMARK
 #include "prthread.h"
@@ -324,42 +323,31 @@ PORT_ArenaZAlloc(PLArenaPool *arena, siz
  * If zero is true, zeroize the arena memory before freeing it.
  */
 void
 PORT_FreeArena(PLArenaPool *arena, PRBool zero)
 {
     PORTArenaPool *pool = (PORTArenaPool *)arena;
     PRLock *       lock = (PRLock *)0;
     size_t         len  = sizeof *arena;
-    extern const PRVersionDescription * libVersionPoint(void);
-    static const PRVersionDescription * pvd;
+    static PRBool  checkedEnv = PR_FALSE;
     static PRBool  doFreeArenaPool = PR_FALSE;
 
     if (!pool)
     	return;
     if (ARENAPOOL_MAGIC == pool->magic ) {
 	len  = sizeof *pool;
 	lock = pool->lock;
 	PZ_Lock(lock);
     }
-    if (!pvd) {
-	/* Each of NSPR's DLLs has a function libVersionPoint().
-	** We could do a lot of extra work to be sure we're calling the
-	** one in the DLL that holds PR_FreeArenaPool, but instead we
-	** rely on the fact that ALL NSPR DLLs in the same directory
-	** must be from the same release, and we call which ever one we get. 
-	*/
+    if (!checkedEnv) {
 	/* no need for thread protection here */
-	pvd = libVersionPoint();
-	if ((pvd->vMajor > 4) || 
-	    (pvd->vMajor == 4 && pvd->vMinor > 1) ||
-	    (pvd->vMajor == 4 && pvd->vMinor == 1 && pvd->vPatch >= 1)) {
-	    const char *ev = PR_GetEnv("NSS_DISABLE_ARENA_FREE_LIST");
-	    if (!ev) doFreeArenaPool = PR_TRUE;
-	}
+	const char *ev = PR_GetEnv("NSS_DISABLE_ARENA_FREE_LIST");
+	if (!ev) doFreeArenaPool = PR_TRUE;
+	checkedEnv = PR_TRUE;
     }
     if (zero) {
 	PLArena *a;
 	for (a = arena->first.next; a; a = a->next) {
 	    PR_ASSERT(a->base <= a->avail && a->avail <= a->limit);
 	    memset((void *)a->base, 0, a->avail - a->base);
 	}
     }
